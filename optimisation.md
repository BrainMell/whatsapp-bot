# Baileys Bot — Logging & Database Guide

> **Purpose:** This document outlines what needs to change in a Baileys WhatsApp bot to eliminate unnecessary console output, persist chat data and errors into MongoDB, and have that data auto-expire — without needing to know the exact codebase. It's intentionally broad so it can be mapped onto whatever structure is already in place.

---

## 1. Silence the Logger

Baileys uses `pino` as its internal logger. By default (or if set to `debug`/`trace`), it dumps full session objects — including cryptographic Buffer data — to the console every time sessions are created or cleaned up. This is the #1 cause of RAM spikes.

**What to do:** Find wherever `makeWASocket` is called and set the logger level to `silent` or `error`.

```js
const pino = require('pino')

const sock = makeWASocket({
  // ... your existing config ...
  logger: pino({ level: 'silent' })  // 'error' if you still want crash logs in terminal
})
```

- `silent` — prints nothing at all.
- `error` — only prints if the connection actually crashes or fails.
- Anything else (`debug`, `trace`, `info`) will still produce output.

**Why it matters:** The logging itself was the heavy part — not the session cleanup it was reporting on. Silencing it removes the serialization and stdout buffering that was eating hundreds of MB.

---

## 2. Remove or Silence All `console.log` for Messages

If anywhere in the codebase there are lines like `console.log(message)` or `console.log('Received:', msg)` that fire on every incoming WhatsApp message — those need to be removed or commented out.

**Why:** Same reason as above. Every `console.log` forces Node.js to serialize the object into a string. At volume, this adds up. The messages should go to the database instead (see Section 3), not to the terminal.

**Search tip:** Open your project in VS Code, press `Ctrl + Shift + F`, and search for:
- `console.log`
- `Removing old closed session`

Any hits related to message handling or session logging should be removed.

---

## 3. MongoDB Setup — Two Collections

You need two collections in your MongoDB database. They serve different purposes and have different lifespans.

### 3a. `chat_messages` — Stores Incoming Messages (Auto-Deletes After 1 Hour)

This is where every incoming message gets written. It replaces whatever is currently being logged to the console or held in memory. Any part of the codebase that needs to *read* message history should query this collection instead.

**Document shape (example):**

```js
{
  _id: ObjectId(),           // auto-generated by MongoDB
  sender: "27821234567@s.whatsapp.net",  // the JID or phone number
  body: "hey what's up",     // the message text (or null for media)
  type: "text",              // text, image, video, audio, etc.
  timestamp: new Date(),     // MUST be a BSON Date — this is what TTL uses
  chatId: "27821234567@s.whatsapp.net"   // the conversation ID, useful for querying
}
```

**TTL Index (auto-delete after 1 hour):**

Run this once — either in your MongoDB shell, Compass, or on app startup. You only need to create it one time.

```js
// In MongoDB shell or via your driver:
db.chat_messages.createIndex(
  { "timestamp": 1 },
  { expireAfterSeconds: 3600 }  // 3600 seconds = 1 hour
)
```

Or in Mongoose / native driver on startup:

```js
// Run once during app initialization
await ChatMessage.collection.createIndex(
  { timestamp: 1 },
  { expireAfterSeconds: 3600 }
)
```

**How it works:** MongoDB has a background thread that checks this index every ~60 seconds. Any document where `timestamp` is older than 1 hour gets automatically deleted. No cron jobs. No external clock. No manual scripts needed.

**Important:** The `timestamp` field *must* be a real BSON `Date` object (i.e., `new Date()`), not a string like `"2025-01-01"`. If it's a string, the TTL index won't work.

---

### 3b. `errors` — Stores Errors and Exceptions (No Auto-Delete)

This is where any errors, failures, or exceptions get written. These should persist longer than chat messages so you can debug issues after the fact. You can add a TTL here too later if needed (e.g., 7 days), but for now keep them indefinitely.

**Document shape (example):**

```js
{
  _id: ObjectId(),
  errorType: "send_failed",        // a label you define (e.g. send_failed, auth_error, timeout)
  message: "Failed to send to 27821234567", // human-readable description
  stack: "Error: ...\n    at ...", // the full stack trace (optional but useful)
  metadata: {                      // anything else that's relevant
    recipientId: "27821234567@s.whatsapp.net",
    messageContent: "hey"
  },
  timestamp: new Date()
}
```

---

## 4. Writing to the Database — Where to Put It in Your Code

You don't need to know the exact code structure for this. The general pattern is:

### For Messages — Write on Receive

Wherever the bot handles an incoming message (usually an event listener like `sock.ev.on('messages.upsert', ...)` or similar), add a database write *after* the message is processed. It should be async and non-blocking — fire and forget.

```js
// Pseudocode — adapt to your actual message handler
onMessageReceived(async (msg) => {
  // ... your existing message handling logic ...

  // Write to MongoDB (non-blocking)
  await ChatMessage.create({
    sender: msg.key.remoteJid,
    body: msg.message?.conversation || null,
    type: "text",                    // adjust based on message type
    timestamp: new Date(),
    chatId: msg.key.remoteJid
  })
})
```

### For Errors — Wrap in Try/Catch

Anywhere the bot does something that could fail (sending a message, connecting, processing media), wrap it in a try/catch and write the error to MongoDB instead of logging it to the console.

```js
// Pseudocode
async function sendMessage(jid, text) {
  try {
    await sock.sendMessage(jid, { text })
  } catch (err) {
    // Write to MongoDB instead of console.log(err)
    await ErrorLog.create({
      errorType: "send_failed",
      message: err.message,
      stack: err.stack,
      metadata: { recipientId: jid, messageContent: text },
      timestamp: new Date()
    })
  }
}
```

---

## 5. Reading Messages From the Database

Any existing code that reads messages — whether for command responses, chat history, or anything else — should now query the `chat_messages` collection instead of reading from memory or a log.

**Example queries:**

```js
// Get the last 10 messages from a specific chat
const recent = await ChatMessage.find({ chatId: jid })
  .sort({ timestamp: -1 })
  .limit(10)

// Get all messages in the last hour (before TTL deletes them)
const cutoff = new Date(Date.now() - 60 * 60 * 1000)
const lastHour = await ChatMessage.find({ timestamp: { $gte: cutoff } })

// Get all messages from a specific sender
const fromSender = await ChatMessage.find({ sender: "27821234567@s.whatsapp.net" })
```

---

## 6. Checklist — What Needs to Happen

| Task | Where | Done? |
|------|-------|-------|
| Set pino logger to `silent` or `error` in `makeWASocket` config | Connection / socket setup file | ☐ |
| Remove or comment out all `console.log` related to messages and sessions | Search entire project for `console.log` | ☐ |
| Create `chat_messages` collection in MongoDB | MongoDB shell / Compass / Atlas | ☐ |
| Create TTL index on `chat_messages.timestamp` with 3600s expiry | Run once on startup or manually | ☐ |
| Create `errors` collection in MongoDB | MongoDB shell / Compass / Atlas | ☐ |
| Add database write in the message receive handler | Message handler file | ☐ |
| Wrap error-prone code in try/catch → write to `errors` collection | Wherever sends / connections happen | ☐ |
| Update any code that reads messages to query MongoDB instead | Anywhere message history is used | ☐ |

---

## 7. Expected RAM After These Changes

With 3,000 messages per day (~2 per minute) and no console spam:

- **Steady state:** ~80–130 MB
- **During message bursts:** ~130–160 MB (briefly, before garbage collection)
- **Previous behavior (with console spam):** 400–600+ MB

The difference is entirely because Node.js no longer has to serialize and buffer objects to the terminal.

---

## Notes

- The TTL index deletion is **not instant**. MongoDB checks every ~60 seconds, so a document might survive up to a minute past its expiry time. This is fine for chat logs.
- The `timestamp` field in `chat_messages` **must** be a native JavaScript `Date` object (`new Date()`), not a string. This is the single most common mistake with TTL indexes.
- If you're using **Mongoose**, you can define the TTL index directly in the schema: `timestamp: { type: Date, expires: '1h' }` — this is equivalent to the manual `createIndex` approach.
- Errors collection has no TTL by default. If it grows too large over time, you can add one later (e.g., 7 days = `expireAfterSeconds: 604800`).